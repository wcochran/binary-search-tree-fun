<!DOCTYPE html>
<html lang="en">
<head>

<meta charset="utf=8" />

<title>BST</title>

<style>
body {
  background-color : gray;
  font-family: "Arial Rounded MT Bold", "Helvetica Rounded", Arial, sans-serif;
}
h1 {
  font-size : 1.2em;
}
footer {
  font-size : 0.9 em;
  font-style: italic;
}
</style>

<script src="bst.js"></script>
<script src="matrix.js"></script>
        
<script id="vertex" type="x-shader">
      attribute vec3 vertexPosition;
      uniform mat4 ModelViewProjection;
      void main() {
          gl_Position = ModelViewProjection*vec4(vertexPosition,1.0);
      }
</script>

<script id="fragment" type="x-shader">
      precision mediump float;
      uniform vec3 objectColor;
      void main() {
         gl_FragColor = vec4(objectColor, 1.0);
      }
</script>

<script>
    var canvas, gl, program;
    var tree = null;
    var treeModified;
    var treeExtent;

    function loadUniforms() {
        var ModelViewProjection = gl.Projection.mult(gl.ModelView);
        gl.uniformMatrix4fv(program.ModelViewProjection, false,
                            ModelViewProjection.array);
        gl.uniform3fv(program.objectColor, gl.objectColor);
    }

    var circle = {
	numVerts : 32,
	VBO : -1,
	loadVBO : function() {
	    var verts = new Float32Array(2*this.numVerts);
	    var dtheta = 2*Math.PI/this.numVerts;
	    for (var i = 0; i < this.numVerts; i++) {
		var theta = i*dtheta;
		verts[2*i] = Math.cos(theta);
		verts[2*i+1] = Math.sin(theta);
	    }
            this.VBO = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, this.VBO);
            gl.bufferData(gl.ARRAY_BUFFER, verts, gl.STATIC_DRAW);
	},
	draw : function(x, y, radius) {
            if (this.VBO < 0)
		this.loadVBO();
	    gl.matrixStack.push(gl.ModelView);
	    gl.ModelView.translate(x,y,0).scale(radius, radius, 1);
            loadUniforms();
            gl.bindBuffer(gl.ARRAY_BUFFER, this.VBO);
            gl.enableVertexAttribArray(program.vertexPosition);
            gl.vertexAttribPointer(program.vertexPosition,
                                   2, gl.FLOAT, false, 0, 0);
            gl.drawArrays(gl.LINE_LOOP, 0, this.numVerts);
	    gl.matrixStack.pop(gl.ModelView);
	}
    }

    var lineSegment = {
	VBO : -1,
	loadVBO : function() {
	    var verts = new Float32Array([0,0, 1,0]);
            this.VBO = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, this.VBO);
            gl.bufferData(gl.ARRAY_BUFFER, verts, gl.STATIC_DRAW);
	},
	draw : function(x0,y0, x1,y1) {
            if (this.VBO < 0)
		this.loadVBO();
	    gl.matrixStack.push(gl.ModelView);
	    var dx = x1 - x0, dy = y1 - y0;
	    var theta = Math.atan2(dy, dx)*180/Math.PI;
	    var len = Math.sqrt(dx*dx + dy*dy);
	    gl.ModelView.translate(x0,y0,0).rotate(theta,0,0,1).scale(len,1,1);
            loadUniforms();
            gl.bindBuffer(gl.ARRAY_BUFFER, this.VBO);
            gl.enableVertexAttribArray(program.vertexPosition);
            gl.vertexAttribPointer(program.vertexPosition,
                                   2, gl.FLOAT, false, 0, 0);
            gl.drawArrays(gl.LINES, 0, 2);
	    gl.matrixStack.pop(gl.ModelView);
	}
    }

   var digit = {
       vertsBuffer : -1,
       elementsBuffer : -1,
       elementOffset : [0, 8, 10, 20, 28, 36, 46, 56, 60, 70],
       elementCount : [8, 2, 10, 8, 8, 10, 10, 4, 10, 10],
       loadVBOs : function() {
	   var verts = new Float32Array([-5/16, 1, 0, 1, 5/16, 1,
					 -5/16, 0, 0, 0, 5/16, 0,
					 -5/16,-1, 0,-1, 5/16,-1]);
	   this.vertsBuffer = gl.createBuffer();
           gl.bindBuffer(gl.ARRAY_BUFFER, this.vertsBuffer);
           gl.bufferData(gl.ARRAY_BUFFER, verts, gl.STATIC_DRAW);
	   var elements = new Uint8Array([0,2, 2,8, 8,6, 6,0,       // 0, offset=0,  n=8
					  1,7,                      // 1, offset=8,  n=2
					  0,2, 2,5, 5,3, 3,6, 6,8,  // 2, offset=10, n=10
					  0,2, 2,8, 8,6, 5,3,       // 3, offset=20, n=8
					  0,3, 3,5, 5,2, 5,8,       // 4, offset=28, n=8
					  2,0, 0,3, 3,5, 5,8, 8,6,  // 5, offset=36, n=10
					  2,0, 0,6, 6,8, 8,5, 5,3,  // 6, offset=46, n=10
					  0,2, 2,8,                 // 7, offset=56, n=4
					  0,2, 2,8, 8,6, 6,0, 3,5,  // 8, offset=60, n=10
					  6,8, 8,2, 2,0, 0,3, 3,5]);// 9, offset=70, n=10
	   this.elementsBuffer = gl.createBuffer();
	   gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.elementsBuffer);
           gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, elements, gl.STATIC_DRAW);
       },
       draw : function(d) {
	   if (this.vertsBuffer < 0)
	       this.loadVBOs();
           gl.bindBuffer(gl.ARRAY_BUFFER, this.vertsBuffer);
           gl.enableVertexAttribArray(program.vertexPosition);
           gl.vertexAttribPointer(program.vertexPosition,
                                  2, gl.FLOAT, false, 0, 0);
	   gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.elementsBuffer);
           gl.drawArrays(gl.LINES, this.elementOffset[d], this.elementCount[d]);
       },
       drawNumber : function(x, y, num) {	
	   gl.matrixStack.push(gl.ModelView);
	   if (num < 10) {  // single digit
	       gl.ModelView.translate(x, y, 0);
	       this.draw(num);
	   } else {
	       var v = num, len = 1;   // count digits
	       while (v >= 10) {
		   v = Math.floor(v / 10);
		   len++;
	       }
	       gl.ModelView.translate(x + (len-1)/2, y, 0);  // draw number backwards
	       while (num > 0) {
		   var d = num % 10;
		   this.draw(d);
		   num = Math.floor(num / 10);
		   gl.ModelView.translate(-1, 0, 0);
	       }
	   }
	   gl.matrixStack.pop(gl.ModelView);
       }
   }

   function init() {
      canvas = document.getElementById("bstcanvas");
      gl = null;
      try {
          gl = canvas.getContext("experimental-webgl");
      } catch(e) {gl = null;}
      if (gl == null) {
          alert("No WebGL -- bummer!");
          return false;
      }
      var v = document.getElementById("vertex").firstChild.nodeValue;
      var vs = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(vs,v);
      gl.compileShader(vs);
      if (!gl.getShaderParameter(vs,gl.COMPILE_STATUS)) {
          alert(gl.getShaderInfoLog(vs));
          return false; 
      }

      var f = document.getElementById("fragment").firstChild.nodeValue;
      var fs = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(fs,f);
      gl.compileShader(fs);
      if (!gl.getShaderParameter(fs,gl.COMPILE_STATUS)) {
          alert(gl.getShaderInfoLog(fs));
          return false;
      }
      
      program = gl.createProgram();
      gl.attachShader(program, vs);
      gl.attachShader(program, fs);
      gl.linkProgram(program);

      gl.useProgram(program);
      
      program.vertexPosition = gl.getAttribLocation(program, "vertexPosition");
      program.ModelViewProjection = gl.getUniformLocation(program, 
							  "ModelViewProjection");
      program.objectColor = gl.getUniformLocation(program, "objectColor");
      
      gl.clearColor(0,0,0.3,1);
      gl.uniform3fv(program.objectColor,[1.0, 1.0, 0.0]);

      gl.matrixStack = new Matrix4x4Stack;
      
      gl.Projection = new Matrix4x4;
      gl.ModelView = new Matrix4x4;

      gl.viewport(0,0, canvas.width, canvas.height);
      
      gl.enable(gl.DEPTH_TEST);
      gl.lineWidth(2.0);

      tree = null;
      var keys = [40, 10, 0, 20, 60, 50, 70];  // initial balanced tree
      for (var i = 0; i < keys.length; i++)
	  tree = insert(tree, keys[i]);
      keys = [10, 11, 50, 45, 22, 3, 52, 80, 0, 1, 2, 3];  // more keys
      for (var i = 0; i < keys.length; i++)
      	  tree = insert(tree, keys[i]);
      treeModified = true;
  }

  var nodeRadius = 0.3;
  var boundary = 0.7;

  function edge(x0,y0, x1,y1) {
      var dx = x1 - x0, dy = y1 - y0;
      var len = Math.sqrt(dx*dx + dy*dy);
      var u = dx/len, v = dy/len;
      lineSegment.draw(x0 + nodeRadius*u, y0 + nodeRadius*v,
		       x1 - nodeRadius*u, y1 - nodeRadius*v);
  }

  function drawTree(tree) {
      // XXXX digit.drawNumber(tree.x, tree.y, tree.key);
      circle.draw(tree.x, tree.y, nodeRadius);
      if (tree.left != null) {
	  edge(tree.x, tree.y, tree.left.x, tree.left.y);
	  drawTree(tree.left);
      }
      if (tree.right != null) {
	  edge(tree.x, tree.y, tree.right.x, tree.right.y);
	  drawTree(tree.right);
      }
  }

  function display() {
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      if (treeModified) {
	  treeExtent = setNodePositions(tree);
	  treeModified = false;
	  var dx = treeExtent.maxx - treeExtent.minx;
	  var dy = treeExtent.maxy - treeExtent.miny;
	  var size = (dx > dy) ? dx : dy;
	  gl.Projection.identity().ortho(treeExtent.minx - boundary, 
					 treeExtent.minx + size + boundary,
					 treeExtent.miny + size + boundary, 
					 treeExtent.miny - boundary, 
					 -1, 1);
	  gl.ModelView.identity();
      }
      
      gl.objectColor = [1, 1, 0];
      drawTree(tree);

      gl.flush();
  }
</script>

</head>
<body onload="init(); display()">

<h1>BST</h1>

<canvas id="bstcanvas" width="600" height="600"></canvas><br />

<footer>
  Wayne O. Cochran<br />
  December 31, 2014
</footer>

</body>
</html>
