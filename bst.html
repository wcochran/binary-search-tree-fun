<!DOCTYPE html>
<html lang="en">
<head>

<meta charset="utf=8" />

<title>BST</title>

<style>
body {
  background-color : gray;
  font-family: "Arial Rounded MT Bold", "Helvetica Rounded", Arial, sans-serif;
}
h1 {
  font-size : 1.2em;
}
footer {
  font-size : 0.9 em;
  font-style: italic;
}
</style>

<script src="bst.js"></script>
<script src="matrix.js"></script>
        
<script id="vertex" type="x-shader">
      attribute vec3 vertexPosition;
      uniform mat4 ModelViewProjection;
      void main() {
          gl_Position = ModelViewProjection*vec4(vertexPosition,1.0);
      }
</script>

<script id="fragment" type="x-shader">
      precision mediump float;
      uniform vec3 objectColor;
      void main() {
         gl_FragColor = vec4(objectColor, 1.0);
      }
</script>

<script>
    var canvas, gl, program;
    var tree = null;
    var treeModified;
    var treeExtent;

    function loadUniforms() {
        var ModelViewProjection = gl.Projection.mult(gl.ModelView);
        gl.uniformMatrix4fv(program.ModelViewProjection, false,
                            ModelViewProjection.array);
        gl.uniform3fv(program.objectColor, gl.objectColor);
    }

    var circle = {
	numVerts : 32,
	VBO : -1,
	loadVBO : function() {
	    var verts = new Float32Array(2*this.numVerts);
	    var dtheta = 2*Math.PI/this.numVerts;
	    for (var i = 0; i < this.numVerts; i++) {
		var theta = i*dtheta;
		verts[2*i] = Math.cos(theta);
		verts[2*i+1] = Math.sin(theta);
	    }
            this.VBO = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, this.VBO);
            gl.bufferData(gl.ARRAY_BUFFER, verts, gl.STATIC_DRAW);
	},
	draw : function(x, y, radius) {
            if (this.VBO < 0)
		this.loadVBO();
	    gl.matrixStack.push(gl.ModelView);
	    gl.ModelView.translate(x,y,0).scale(radius, radius, 1);
            loadUniforms();
            gl.bindBuffer(gl.ARRAY_BUFFER, this.VBO);
            gl.enableVertexAttribArray(program.vertexPosition);
            gl.vertexAttribPointer(program.vertexPosition,
                                   2, gl.FLOAT, false, 0, 0);
            gl.drawArrays(gl.LINE_LOOP, 0, this.numVerts);
	    gl.matrixStack.pop(gl.ModelView);
	}
    }

    var lineSegment = {
	VBO : -1,
	loadVBO : function() {
	    var verts = new Float32Array([0,0, 1,0]);
            this.VBO = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, this.VBO);
            gl.bufferData(gl.ARRAY_BUFFER, verts, gl.STATIC_DRAW);
	},
	draw : function(x0,y0, x1,y1) {
            if (this.VBO < 0)
		this.loadVBO();
	    gl.matrixStack.push(gl.ModelView);
	    var dx = x1 - x0, dy = y1 - y0;
	    var theta = Math.atan2(dy, dx)*180/Math.PI;
	    var len = Math.sqrt(dx*dx + dy*dy);
	    gl.ModelView.translate(x0,y0,0).rotate(theta,0,0,1).scale(len,1,1);
            loadUniforms();
            gl.bindBuffer(gl.ARRAY_BUFFER, this.VBO);
            gl.enableVertexAttribArray(program.vertexPosition);
            gl.vertexAttribPointer(program.vertexPosition,
                                   2, gl.FLOAT, false, 0, 0);
            gl.drawArrays(gl.LINES, 0, 2);
	    gl.matrixStack.pop(gl.ModelView);
	}
    }

  function init() {
      canvas = document.getElementById("bstcanvas");
      gl = null;
      try {
          gl = canvas.getContext("experimental-webgl");
      } catch(e) {gl = null;}
      if (gl == null) {
          alert("No WebGL -- bummer!");
          return false;
      }
      var v = document.getElementById("vertex").firstChild.nodeValue;
      var vs = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(vs,v);
      gl.compileShader(vs);
      if (!gl.getShaderParameter(vs,gl.COMPILE_STATUS)) {
          alert(gl.getShaderInfoLog(vs));
          return false; 
      }

      var f = document.getElementById("fragment").firstChild.nodeValue;
      var fs = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(fs,f);
      gl.compileShader(fs);
      if (!gl.getShaderParameter(fs,gl.COMPILE_STATUS)) {
          alert(gl.getShaderInfoLog(fs));
          return false;
      }
      
      program = gl.createProgram();
      gl.attachShader(program, vs);
      gl.attachShader(program, fs);
      gl.linkProgram(program);

      gl.useProgram(program);
      
      program.vertexPosition = gl.getAttribLocation(program, "vertexPosition");
      program.ModelViewProjection = gl.getUniformLocation(program, 
							  "ModelViewProjection");
      program.objectColor = gl.getUniformLocation(program, "objectColor");
      
      gl.clearColor(0,0,0.3,1);
      gl.uniform3fv(program.objectColor,[1.0, 1.0, 0.0]);

      gl.matrixStack = new Matrix4x4Stack;
      
      gl.Projection = new Matrix4x4;
      gl.ModelView = new Matrix4x4;

      gl.viewport(0,0, canvas.width, canvas.height);
      
      gl.enable(gl.DEPTH_TEST);
      gl.lineWidth(2.0);

      tree = null;
      var keys = [40, 10, 0, 20, 60, 50, 70];  // initial balanced tree
      for (var i = 0; i < keys.length; i++)
	  tree = insert(tree, keys[i]);
      keys = [10, 11, 50, 45, 22, 3, 52, 80, 0, 1, 2, 3];  // more keys
      for (var i = 0; i < keys.length; i++)
      	  tree = insert(tree, keys[i]);
      treeModified = true;
  }

  var nodeRadius = 0.3;
  var boundary = 0.7;

  function edge(x0,y0, x1,y1) {
      var dx = x1 - x0, dy = y1 - y0;
      var len = Math.sqrt(dx*dx + dy*dy);
      var u = dx/len, v = dy/len;
      lineSegment.draw(x0 + nodeRadius*u, y0 + nodeRadius*v,
		       x1 - nodeRadius*u, y1 - nodeRadius*v);
  }

  function drawTree(tree) {
      circle.draw(tree.x, tree.y, nodeRadius);
      if (tree.left != null) {
	  edge(tree.x, tree.y, tree.left.x, tree.left.y);
	  drawTree(tree.left);
      }
      if (tree.right != null) {
	  edge(tree.x, tree.y, tree.right.x, tree.right.y);
	  drawTree(tree.right);
      }
  }

  function display() {
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      if (treeModified) {
	  treeExtent = setNodePositions(tree);
	  treeModified = false;
	  var dx = treeExtent.maxx - treeExtent.minx;
	  var dy = treeExtent.maxy - treeExtent.miny;
	  var size = (dx > dy) ? dx : dy;
	  gl.Projection.identity().ortho(treeExtent.minx - boundary, 
					 treeExtent.minx + size + boundary,
					 treeExtent.miny + size + boundary, 
					 treeExtent.miny - boundary, 
					 -1, 1);
	  /* XXX
	  gl.Projection.identity().ortho(treeExtent.minx, treeExtent.maxx,
					 treeExtent.maxy, treeExtent.miny,
					 -1, 1);
	  */
	  gl.ModelView.identity();
      }
      
      gl.objectColor = [1, 1, 0];
      drawTree(tree);

      gl.flush();
  }
</script>

</head>
<body onload="init(); display()">

<h1>BST</h1>

<canvas id="bstcanvas" width="600" height="600"></canvas><br />

<footer>
  Wayne O. Cochran<br />
  December 31, 2014
</footer>

</body>
</html>
